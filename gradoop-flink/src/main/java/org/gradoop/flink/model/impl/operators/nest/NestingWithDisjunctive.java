package org.gradoop.flink.model.impl.operators.nest;

import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.common.model.impl.pojo.GraphHeadFactory;
import org.gradoop.flink.model.impl.GraphCollection;
import org.gradoop.flink.model.impl.LogicalGraph;
import org.gradoop.flink.model.impl.operators.nest.model.NormalizedGraph;
import org.gradoop.flink.model.impl.operators.nest.model.indices.IndexingAfterNesting;
import org.gradoop.flink.model.impl.operators.nest.operators.DisjunctiveEdges;
import org.gradoop.flink.model.impl.operators.nest.transformations
  .NestedIndexingToEPGMTransformations;

/**
 * Implements the nesting operation
 */
public class NestingWithDisjunctive extends Nesting {

  /**
   * A default id is generated by using the GraphHeadFactory
   * @param ghf Generating the ids for the headers
   */
  public NestingWithDisjunctive(GraphHeadFactory ghf) {
    super(ghf);
  }

  /**
   * A default id is associated to the graph
   * @param id Id to be associated to the new graph
   */
  public NestingWithDisjunctive(GradoopId id) {
    super(id);
  }

  @Override
  public LogicalGraph execute(LogicalGraph left, GraphCollection collection) {
    initialize(left, collection);

    DisjunctiveEdges de = new DisjunctiveEdges(getId());

    de.setDataLake(getNormalizedRepresentation());

    IndexingAfterNesting iaf = de.with(getIntermediateResult(),getRightIdx());

    NormalizedGraph updated = de.updateFlatModel(getNormalizedRepresentation(),iaf);

    return NestedIndexingToEPGMTransformations.toLogicalGraph(iaf,updated);
  }

}
